name: Code Factory

on:
  pull_request:
    branches: [ master ]
  push:
    branches: [ master ]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  gate:
    name: gate
    runs-on: ubuntu-latest
    outputs:
      riskTier: ${{ steps.policy.outputs.riskTier }}
      requiredChecks: ${{ steps.policy.outputs.requiredChecks }}
      touchedPaths: ${{ steps.policy.outputs.touchedPaths }}
      baseSha: ${{ steps.shas.outputs.base }}
      headSha: ${{ steps.shas.outputs.head }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install gate dependencies
        run: python3 -m pip install --disable-pip-version-check --no-cache-dir pyyaml

      - name: Compute base/head
        id: shas
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "base=${{ github.event.pull_request.base.sha }}" >> "$GITHUB_OUTPUT"
            echo "head=${{ github.event.pull_request.head.sha }}" >> "$GITHUB_OUTPUT"
          else
            # Handle initial-commit / no-parent edge case on push events
            if git rev-parse --verify HEAD^ >/dev/null 2>&1; then
              echo "base=$(git rev-parse HEAD^)" >> "$GITHUB_OUTPUT"
            else
              # Fall back to HEAD when there is no parent
              echo "base=$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"
            fi
            echo "head=$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"
          fi
      - name: Validate risk policy contract
        run: |
          set -euo pipefail
          python3 ops/scripts/policy/validate_risk_policy.py


      - name: Run risk policy gate
        id: policy
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          BASE_SHA: ${{ steps.shas.outputs.base }}
          HEAD_SHA: ${{ steps.shas.outputs.head }}
        run: |
          set -euo pipefail
          python3 ops/scripts/policy/risk_policy_gate.py | tee gate_output.json

      - name: Apply risk label

        if: always()

        continue-on-error: true

        env:

          PR: ${{ github.event.pull_request.number }}

          REPO: ${{ github.repository }}

          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

        run: |

          set -euo pipefail


          if [ ! -f gate_output.json ]; then

            echo "gate_output.json missing; skip labeling"

            exit 0

          fi


          echo "Reading gate_output.json (labelsToApply)..."

          cat gate_output.json || true


          # labelsToApply is gate-emitted; expected like: ["risk:low","control-plane"]

          mapfile -t LABELS < <(jq -r '.labelsToApply[]? // empty' gate_output.json 2>/dev/null || true)


          if [ "${#LABELS[@]}" -eq 0 ]; then

            echo "WARN: no labelsToApply in gate_output.json; skipping label apply"

            exit 0

          fi


          echo "labelsToApply=${LABELS[*]}"


          RISK_LABEL=""

          OTHER_LABELS=()

          for L in "${LABELS[@]}"; do

            if [[ "$L" == risk:* ]]; then

              RISK_LABEL="$L"

            else

              OTHER_LABELS+=("$L")

            fi

          done


          # --- Apply risk label (remove other risk:* first), best-effort ---

          if [ -n "$RISK_LABEL" ]; then

            echo "Desired risk label: $RISK_LABEL"


            gh label create "$RISK_LABEL" --color "ededed" --description "Code Factory: contract-driven risk tier label" 2>/dev/null || true


            EXISTING="$(gh pr view "$PR" --repo "$REPO" --json labels -q '.labels[].name' 2>/dev/null || true)"

            for l in $EXISTING; do

              case "$l" in

                risk:*)

                  [ "$l" = "$RISK_LABEL" ] || (gh pr edit "$PR" --repo "$REPO" --remove-label "$l" 2>/dev/null || true)

                  ;;

              esac

            done


            gh pr edit "$PR" --repo "$REPO" --add-label "$RISK_LABEL" 2>/dev/null || true

          fi


          # --- Apply non-risk labels (e.g., control-plane), best-effort ---

          for L in "${OTHER_LABELS[@]}"; do

            [ -n "$L" ] || continue

            echo "Applying label: $L"

            gh label create "$L" --color "ededed" --description "Code Factory: contract-driven label" 2>/dev/null || true

            gh pr edit "$PR" --repo "$REPO" --add-label "$L" 2>/dev/null || true

          done


          echo "OK: label step completed (best-effort)"

      - name: Request CodeRabbit rerun (canonical, sha-deduped)
        if: ${{ github.event_name == 'pull_request' && !github.event.pull_request.head.repo.fork && contains(steps.policy.outputs.requiredChecks, 'code-review-head') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          HEAD_SHA: ${{ steps.shas.outputs.head }}
          CODERABBIT_MENTION: "@coderabbitai"
        run: |
          set -euo pipefail
          python ops/scripts/policy/request_coderabbit_rerun.py


      - name: Require CodeRabbit review evidence (current-head)
        if: ${{ github.event_name == 'pull_request' && contains(steps.policy.outputs.requiredChecks, '"code-review-head"') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          HEAD_SHA: ${{ steps.shas.outputs.head }}
          TIMEOUT_MINUTES: "20"
        run: |
          set -euo pipefail
          python ops/scripts/policy/require_coderabbit_review.py

      # Optional: makes debugging PR failures dead simple
      - name: Debug gate outputs
        if: ${{ always() }}
        run: |
          echo "riskTier=${{ steps.policy.outputs.riskTier }}"
          echo "requiredChecks=${{ steps.policy.outputs.requiredChecks }}"
          echo "touchedPaths=${{ steps.policy.outputs.touchedPaths }}"
          echo "baseSha=${{ steps.shas.outputs.base }}"
          echo "headSha=${{ steps.shas.outputs.head }}"

  ci:
    name: ci
    runs-on: ubuntu-latest
    needs: [ gate ]
    steps:
      - uses: actions/checkout@v4

      # --- Put your real CI steps here ---
      # Python example (keep/remove depending on your repo):
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: CI smoke
        run: |
          set -euo pipefail
          python -m py_compile ops/scripts/policy/risk_policy_gate.py

      # Node example (only if you actually use Node):
      # - uses: actions/setup-node@v4
      #   with:
      #     node-version: "20"
      # - run: npm ci
      # - run: npm test

  auto-merge-low:
    name: Auto-merge low-risk PRs
    if: ${{ github.event_name == 'pull_request' && !github.event.pull_request.head.repo.fork }}
    runs-on: ubuntu-latest
    needs: [gate, ci]
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout (for audit emitter)
        uses: actions/checkout@v4

      - name: Decide auto-merge
        id: decide
        run: |
          set -euo pipefail
          RISK='${{ needs.gate.outputs.riskTier }}'
          echo "riskTier=$RISK"
          if [ "$RISK" = "low" ]; then
            echo "enable=true" >> "$GITHUB_OUTPUT"
          else
            echo "enable=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Guard auto-merge (checks green + auto-merge allowed)
        id: guard
        if: ${{ steps.decide.outputs.enable == 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
          REQUIRED: ${{ needs.gate.outputs.requiredChecks }}
        run: |
          set -euo pipefail
          allow_auto_merge="$(gh api "repos/$REPO" --jq '.allow_auto_merge' 2>/dev/null || echo 'false')"
          if [ "$allow_auto_merge" != "true" ]; then
            echo "ok=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          if [ -z "${REQUIRED:-}" ]; then
            echo "No requiredChecks provided; refusing auto-merge."
            echo "ok=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          mapfile -t required_checks < <(printf '%s\n' "$REQUIRED" | jq -r '.[]?' 2>/dev/null || true)
          if [ "${#required_checks[@]}" -eq 0 ]; then
            echo "requiredChecks is empty; refusing auto-merge."
            echo "ok=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          checks_json="$(gh api "repos/$REPO/commits/$HEAD_SHA/check-runs" -H "Accept: application/vnd.github+json" 2>/dev/null || echo '{"check_runs":[]}' )"
          for check in "${required_checks[@]}"; do
            [ -n "$check" ] || continue
            status="$(printf '%s\n' "$checks_json" | jq -r --arg name "$check" '.check_runs[] | select(.name == $name) | .status' | head -n1)"
            conclusion="$(printf '%s\n' "$checks_json" | jq -r --arg name "$check" '.check_runs[] | select(.name == $name) | .conclusion' | head -n1)"
            if [ -z "$status" ] || [ -z "$conclusion" ]; then
              echo "Required check missing: $check"
              echo "ok=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            if [ "$status" != "completed" ] || [ "$conclusion" != "success" ]; then
              echo "Required check not green: $check status=$status conclusion=$conclusion"
              echo "ok=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          done
          echo "ok=true" >> "$GITHUB_OUTPUT"

      - name: Merge PR (squash) (Code Factory)
        if: ${{ steps.decide.outputs.enable == 'true' && steps.guard.outputs.ok == 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR: ${{ github.event.pull_request.number }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          echo "Merging PR #$PR (squash) into $REPO (guarded: required checks green)"
          gh pr merge "$PR" --repo "$REPO" --squash --delete-branch=false 2>/dev/null || true
          echo "OK: merge attempted (best-effort)"
      - name: Emit merge audit record (artifact + summary)
        if: ${{ steps.decide.outputs.enable == 'true' }}
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
          RISK_TIER: ${{ needs.gate.outputs.riskTier }}
          POLICY_VERSION: ${{ needs.gate.outputs.policyVersion }}
          MERGE_METHOD: SQUASH
        run: |
          set -euo pipefail
          python3 ops/scripts/policy/emit_merge_audit.py             --out-json /tmp/code_factory_merge_audit.json             --append-jsonl /tmp/code_factory_merge_ledger.jsonl             --out-summary "$GITHUB_STEP_SUMMARY"

      - name: Upload merge audit artifact
        if: ${{ steps.decide.outputs.enable == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: code-factory-merge-audit
          path: |
            /tmp/code_factory_merge_audit.json
            /tmp/code_factory_merge_ledger.jsonl


      - name: Verify required status contexts match ruleset
        env:
          GH_TOKEN: ${{ github.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          set -euo pipefail
          # Auto-detect ruleset id by name (avoid hardcoding)
          RULESET_NAME="master"
          RULESET_ID=$(gh api "repos/${GITHUB_REPOSITORY}/rulesets" -q '.[] | select(.name=="'"${RULESET_NAME}"'") | .id' | head -n1)
          test -n "${RULESET_ID}" || { echo "ERROR: could not find ruleset named ${RULESET_NAME}"; exit 2; }
          export RULESET_ID
          scripts/verify_required_status_contexts.py
