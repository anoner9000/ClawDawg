#!/usr/bin/env bash
set -euo pipefail

RESP="${1:-}"
if [[ -z "$RESP" || ! -f "$RESP" ]]; then
  echo "Usage: $0 /path/to/llm_response_*.json" >&2
  exit 2
fi

RUNTIME_DIR="${OPENCLAW_RUNTIME_DIR:-$HOME/.openclaw/runtime}"
OUT_JSONL="$RUNTIME_DIR/logs/heartbeat/llm_usage.jsonl"
RATES_FILE="$RUNTIME_DIR/config.known-good/model_rates.json"

mkdir -p "$(dirname "$OUT_JSONL")"
touch "$OUT_JSONL"

python3 - "$RESP" "$OUT_JSONL" "$RATES_FILE" <<'PY'
import json, sys, os, time, datetime

resp_path, out_jsonl, rates_path = sys.argv[1], sys.argv[2], sys.argv[3]

obj = json.load(open(resp_path, "r", encoding="utf-8"))

# --- stable identity (dedupe) ---
resp_id = obj.get("id") or ""
if not resp_id:
    # fall back to path-based dedupe key
    resp_id = os.path.abspath(resp_path)

# If already recorded, exit success (idempotent)
needle = f'"source":"{resp_path}"'
needle2 = f'"response_id":"{resp_id}"'
try:
    with open(out_jsonl, "r", encoding="utf-8", errors="ignore") as f:
        data = f.read()
        if needle in data or needle2 in data:
            print("usage_already_recorded")
            raise SystemExit(0)
except FileNotFoundError:
    pass

usage = obj.get("usage") or {}
it = usage.get("input_tokens", None)
ot = usage.get("output_tokens", None)
tt = usage.get("total_tokens", None)

# Some variants might omit total_tokens; recompute if needed
if it is None or ot is None:
    print("ERROR: usage missing input_tokens/output_tokens", file=sys.stderr)
    raise SystemExit(3)
if tt is None:
    tt = int(it) + int(ot)

model = obj.get("model") or "unknown"

# created_at in response is epoch seconds
created_at = obj.get("created_at")
if isinstance(created_at, (int, float)):
    created_at = int(created_at)
else:
    created_at = int(time.time())

# date in local time (America/Chicago not required for accounting, but keep consistent with prior)
dt = datetime.datetime.fromtimestamp(created_at)
date_str = dt.strftime("%Y-%m-%d")

# ---- cost calc from pinned rates file (if present) ----
cost = None
rate_res = "missing"
try:
    rates = json.load(open(rates_path, "r", encoding="utf-8"))
    # Accept either:
    # { "models": { "gpt-5-mini-...": {"input_usd_per_1k":..., "output_usd_per_1k":...}}}
    # or flat { "gpt-5-mini-...": {...}}
    models = rates.get("models") if isinstance(rates, dict) else None
    if isinstance(models, dict):
        r = models.get(model)
    elif isinstance(rates, dict):
        r = rates.get(model)
    else:
        r = None

    if isinstance(r, dict):
        # allow multiple key spellings
        in1k = (r.get("input_usd_per_1k")
                or r.get("prompt_usd_per_1k")
                or r.get("input_per_1k_usd"))
        out1k = (r.get("output_usd_per_1k")
                 or r.get("completion_usd_per_1k")
                 or r.get("output_per_1k_usd"))
        if in1k is not None and out1k is not None:
            cost = (int(it)/1000.0)*float(in1k) + (int(ot)/1000.0)*float(out1k)
            cost = round(cost, 6)
            rate_res = "exact"
except Exception:
    # keep cost None if any trouble
    pass

rec = {
    "created_at": created_at,
    "date": date_str,
    "model": model,
    "input_tokens": int(it),
    "output_tokens": int(ot),
    "total_tokens": int(tt),
    "cost_usd": cost,
    "rate_res": rate_res,
    "response_id": resp_id,
    "source": os.path.abspath(resp_path),
}

with open(out_jsonl, "a", encoding="utf-8") as f:
    f.write(json.dumps(rec, ensure_ascii=False) + "\n")

print("usage_appended")
PY
