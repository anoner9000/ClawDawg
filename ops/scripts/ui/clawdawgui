#!/usr/bin/env bash
set -euo pipefail

PORT="${CLAWDAWGUI_PORT:-8791}"
HOST="${CLAWDAWGUI_HOST:-127.0.0.1}"
ROOT="$HOME/.openclaw/workspace"
PY="$ROOT/.venv/bin/python"
export OPENCLAW_UI_DRY_RUN="${OPENCLAW_UI_DRY_RUN:-0}"
PID_FILE="$HOME/.openclaw/runtime/var/clawdawgui.pid"
WATCH_PID_FILE="$HOME/.openclaw/runtime/var/clawdawgui.watch.pid"
MODE_FILE="$HOME/.openclaw/runtime/var/clawdawgui.mode"
LOG_FILE="$HOME/.openclaw/runtime/logs/clawdawgui.log"
WATCH_LOG_FILE="$HOME/.openclaw/runtime/logs/clawdawgui.watch.log"

mkdir -p "$(dirname "$PID_FILE")" "$(dirname "$LOG_FILE")" "$(dirname "$WATCH_LOG_FILE")"

port_pids() {
  ss -ltnp 2>/dev/null \
    | awk -v needle="${HOST}:${PORT}" '$4 == needle {print}' \
    | grep -oE 'pid=[0-9]+' \
    | cut -d= -f2 \
    | sort -u
}

wait_for_listener() {
  local i
  for i in {1..25}; do
    local pids
    pids="$(port_pids || true)"
    if [[ -n "$pids" ]]; then
      echo "$pids" | head -n 1
      return 0
    fi
    sleep 0.1
  done
  return 1
}

listener_pids_csv() {
  local pids
  pids="$(port_pids || true)"
  if [[ -z "$pids" ]]; then
    echo ""
    return 0
  fi
  echo "$pids" | paste -sd, -
}

clear_stale_port_holders() {
  local pids
  pids="$(port_pids || true)"
  [[ -n "$pids" ]] || return 0
  while read -r p; do
    [[ -n "$p" ]] || continue
    kill "$p" 2>/dev/null || true
  done <<< "$pids"
  sleep 1
  pids="$(port_pids || true)"
  [[ -n "$pids" ]] || return 0
  while read -r p; do
    [[ -n "$p" ]] || continue
    kill -9 "$p" 2>/dev/null || true
  done <<< "$pids"
}

is_running() {
  if [[ ! -f "$PID_FILE" ]]; then
    return 1
  fi
  local pid
  pid="$(cat "$PID_FILE" 2>/dev/null || true)"
  [[ -n "$pid" ]] || return 1
  kill -0 "$pid" 2>/dev/null
}

is_watch_running() {
  if [[ ! -f "$WATCH_PID_FILE" ]]; then
    return 1
  fi
  local pid
  pid="$(cat "$WATCH_PID_FILE" 2>/dev/null || true)"
  [[ -n "$pid" ]] || return 1
  kill -0 "$pid" 2>/dev/null
}

stop_watch_group() {
  [[ -f "$WATCH_PID_FILE" ]] || return 0
  local wpid
  wpid="$(cat "$WATCH_PID_FILE" 2>/dev/null || true)"
  [[ -n "$wpid" ]] || return 0

  # If it's already dead, just clean pidfile.
  if ! kill -0 "$wpid" 2>/dev/null; then
    rm -f "$WATCH_PID_FILE"
    return 0
  fi

  # setsid => kill the whole process group
  kill -TERM "-$wpid" 2>/dev/null || true
  sleep 0.3
  if kill -0 "$wpid" 2>/dev/null; then
    kill -KILL "-$wpid" 2>/dev/null || true
  fi

  local remain
  remain="$(
    ps -eo pid=,args= \
      | rg "pnpm run watch|sass .*--watch|esbuild .*--watch" \
      | awk '{print $1}' \
      | while read -r pid; do
          [[ -n "$pid" ]] || continue
          cwd="$(readlink -f "/proc/$pid/cwd" 2>/dev/null || true)"
          if [[ "$cwd" == "$ROOT/ui/dashboard" ]]; then
            echo "$pid"
          fi
        done \
      | wc -l
  )"
  echo "proof(stop_watch_group): remaining_dashboard_watchers=$remain" | tee -a "$LOG_FILE"

  rm -f "$WATCH_PID_FILE"
}

cleanup_stale_dashboard_watchers() {
  local watch_dir
  watch_dir="$ROOT/ui/dashboard"

  # If watcher pidfile is valid, keep it.
  if is_watch_running; then
    return 0
  fi

  # Stale/missing pidfile: remove it and clean orphaned dashboard watch processes.
  rm -f "$WATCH_PID_FILE"
  local pids
  pids="$(pgrep -f "pnpm.*watch|pnpm run watch" || true)"
  [[ -n "$pids" ]] || return 0

  while read -r p; do
    [[ -n "$p" ]] || continue
    [[ -d "/proc/$p" ]] || continue
    local cwd
    cwd="$(readlink -f "/proc/$p/cwd" 2>/dev/null || true)"
    if [[ "$cwd" == "$watch_dir" ]]; then
      kill "$p" 2>/dev/null || true
    fi
  done <<< "$pids"
}

mode() {
  if [[ -f "$MODE_FILE" ]]; then
    cat "$MODE_FILE"
    return
  fi
  echo "normal"
}

start() {
  if is_running; then
    local m
    m="$(mode)"
    if [[ "$m" == "normal" ]]; then
      echo "clawdawgui already running (pid $(cat "$PID_FILE"))"
      return 0
    fi
    stop || true
  fi
  clear_stale_port_holders
  cd "$ROOT"
  nohup "$PY" -m uvicorn ui.dashboard.app:app --host "$HOST" --port "$PORT" >>"$LOG_FILE" 2>&1 </dev/null &
  sleep 0.2
  if pid="$(wait_for_listener)"; then
    echo "$pid" > "$PID_FILE"
    echo "normal" > "$MODE_FILE"
    echo "clawdawgui started (pid $pid) on http://$HOST:$PORT"
  else
    echo "failed to start clawdawgui (no listener on $HOST:$PORT)"
    tail -n 80 "$LOG_FILE" || true
    return 1
  fi
}

start_dev() {
  if is_running; then
    local m
    m="$(mode)"
    if [[ "$m" == "dev" ]]; then
      echo "clawdawgui already running (pid $(cat "$PID_FILE")) in dev mode"
      return 0
    fi
    stop || true
  fi
  cleanup_stale_dashboard_watchers
  clear_stale_port_holders
  "$ROOT/ops/scripts/ui/bootstrap_dashboard.sh" >>"$LOG_FILE" 2>&1
  cd "$ROOT/ui/dashboard"
  nohup setsid env PNPM_STORE_DIR="$HOME/.local/share/pnpm/store/v10" pnpm run watch >>"$WATCH_LOG_FILE" 2>&1 </dev/null &
  echo "$!" > "$WATCH_PID_FILE"
  cd "$ROOT"
  nohup "$PY" -m uvicorn ui.dashboard.app:app --host "$HOST" --port "$PORT" >>"$LOG_FILE" 2>&1 </dev/null &
  local uv_supervisor_pid
  uv_supervisor_pid="$!"
  sleep 0.2
  if pid="$(wait_for_listener)"; then
    local code_root code_css code_js
    code_root="$(curl --max-time 3 --connect-timeout 1 -sS -o /dev/null -w '%{http_code}' "http://$HOST:$PORT/" 2>/dev/null || printf '000')"
    code_css="$(curl --max-time 3 --connect-timeout 1 -sS -o /dev/null -w '%{http_code}' "http://$HOST:$PORT/static/app.bundle.css" 2>/dev/null || printf '000')"
    code_js="$(curl --max-time 3 --connect-timeout 1 -sS -o /dev/null -w '%{http_code}' "http://$HOST:$PORT/static/dashboard.bundle.js" 2>/dev/null || printf '000')"
    echo "proof: root=$code_root css=$code_css js=$code_js" | tee -a "$LOG_FILE"
    if [[ "$code_root" != "200" || "$code_css" != "200" || "$code_js" != "200" ]]; then
      echo "failed to start clawdawgui dev mode (health check failed root=$code_root css=$code_css js=$code_js)"
      kill "$uv_supervisor_pid" 2>/dev/null || true
      clear_stale_port_holders || true
      if [[ -f "$WATCH_PID_FILE" ]]; then
        stop_watch_group
      fi
      rm -f "$PID_FILE" "$WATCH_PID_FILE" "$MODE_FILE"
      tail -n 80 "$LOG_FILE" || true
      return 1
    fi
    echo "$uv_supervisor_pid" > "$PID_FILE"
    echo "dev" > "$MODE_FILE"
    echo "clawdawgui started in dev mode (pid $uv_supervisor_pid; listener $pid) on http://$HOST:$PORT"
  else
    echo "failed to start clawdawgui dev mode (no listener on $HOST:$PORT)"
    tail -n 80 "$LOG_FILE" || true
    return 1
  fi
}

start_dev_reload() {
  if is_running; then
    local m
    m="$(mode)"
    if [[ "$m" == "dev-reload" ]]; then
      echo "clawdawgui already running (pid $(cat "$PID_FILE")) in dev-reload mode"
      return 0
    fi
    stop || true
  fi
  cleanup_stale_dashboard_watchers
  clear_stale_port_holders
  "$ROOT/ops/scripts/ui/bootstrap_dashboard.sh" >>"$LOG_FILE" 2>&1
  echo "mode=dev-reload (nondeterministic)" | tee -a "$LOG_FILE"
  cd "$ROOT/ui/dashboard"
  nohup setsid env PNPM_STORE_DIR="$HOME/.local/share/pnpm/store/v10" pnpm run watch >>"$WATCH_LOG_FILE" 2>&1 </dev/null &
  echo "$!" > "$WATCH_PID_FILE"
  cd "$ROOT"
  nohup "$PY" -m uvicorn ui.dashboard.app:app --host "$HOST" --port "$PORT" --reload >>"$LOG_FILE" 2>&1 </dev/null &
  local uv_supervisor_pid
  uv_supervisor_pid="$!"
  sleep 0.2
  if pid="$(wait_for_listener)"; then
    local code_root code_css code_js
    code_root="$(curl --max-time 3 --connect-timeout 1 -sS -o /dev/null -w '%{http_code}' "http://$HOST:$PORT/" 2>/dev/null || printf '000')"
    code_css="$(curl --max-time 3 --connect-timeout 1 -sS -o /dev/null -w '%{http_code}' "http://$HOST:$PORT/static/app.bundle.css" 2>/dev/null || printf '000')"
    code_js="$(curl --max-time 3 --connect-timeout 1 -sS -o /dev/null -w '%{http_code}' "http://$HOST:$PORT/static/dashboard.bundle.js" 2>/dev/null || printf '000')"
    echo "proof(dev-reload): root=$code_root css=$code_css js=$code_js" | tee -a "$LOG_FILE"
    echo "$uv_supervisor_pid" > "$PID_FILE"
    echo "dev-reload" > "$MODE_FILE"
    echo "clawdawgui started in dev-reload mode (pid $uv_supervisor_pid; listener $pid) on http://$HOST:$PORT"
  else
    echo "failed to start clawdawgui dev-reload mode (no listener on $HOST:$PORT)"
    kill "$uv_supervisor_pid" 2>/dev/null || true
    if [[ -f "$WATCH_PID_FILE" ]]; then
      stop_watch_group
    fi
    clear_stale_port_holders || true
    rm -f "$PID_FILE" "$WATCH_PID_FILE" "$MODE_FILE"
    tail -n 80 "$LOG_FILE" || true
    return 1
  fi
}

stop() {
  if ! is_running; then
    echo "clawdawgui is not running"
    rm -f "$PID_FILE"
  else
    local pid
    pid="$(cat "$PID_FILE")"
    kill "$pid" 2>/dev/null || true
    sleep 1
    if kill -0 "$pid" 2>/dev/null; then
      kill -9 "$pid" 2>/dev/null || true
    fi
    rm -f "$PID_FILE"
    echo "clawdawgui stopped"
  fi

  if is_watch_running; then
    stop_watch_group
    echo "clawdawgui watcher stopped"
  fi
  rm -f "$WATCH_PID_FILE" "$MODE_FILE"
  clear_stale_port_holders || true
  return 0
}

status() {
  if is_running; then
    local m
    local lp
    m="$(mode)"
    lp="$(listener_pids_csv)"
    if [[ "$m" == "dev" ]] && is_watch_running; then
      if [[ -n "$lp" ]]; then
        echo "running (pid $(cat "$PID_FILE")) [dev+watch] listeners=[$lp] on http://$HOST:$PORT"
      else
        echo "running (pid $(cat "$PID_FILE")) [dev+watch] on http://$HOST:$PORT"
      fi
    else
      if [[ -n "$lp" ]]; then
        echo "running (pid $(cat "$PID_FILE")) [$m] listeners=[$lp] on http://$HOST:$PORT"
      else
        echo "running (pid $(cat "$PID_FILE")) [$m] on http://$HOST:$PORT"
      fi
    fi
  else
    echo "stopped"
    return 1
  fi
}

logs() {
  tail -n 80 "$LOG_FILE"
  if [[ -f "$WATCH_LOG_FILE" ]]; then
    echo "--- watcher ---"
    tail -n 40 "$WATCH_LOG_FILE"
  fi
}

case "${1:-}" in
  start) start ;;
  dev) start_dev ;;
  dev-reload) start_dev_reload ;;
  prod)
    stop || true
    start
    ;;
  stop) stop ;;
  restart)
    m="$(mode)"
    stop || true
    if [[ "$m" == "dev" ]] || [[ "$m" == "dev-reload" ]]; then
      # preserve reload flavor if you implement it, else treat as dev
      if [[ "$m" == "dev-reload" ]]; then
        start_dev_reload
      else
        start_dev
      fi
    else
      start
    fi
    ;;
  status) status ;;
  logs) logs ;;
  *)
    echo "Usage: $0 {start|dev|dev-reload|prod|stop|restart|status|logs}"
    exit 2
    ;;
esac
